from keras.callbacks import TensorBoard
from keras.layers import Input, Convolution2D, BatchNormalization, Deconvolution2D, Activation
from keras.models import Model
from keras.preprocessing.image import ImageDataGenerator

from datasets.TinyImagenet import TinyImagenet
from utils import montage

batch_size = 250
nb_epoch = 10

# Get the data-set object
data = TinyImagenet()

# Image dimensions
img_rows, img_cols, img_channels = data.get_dims()

input_img = Input(shape=(img_rows, img_cols, img_channels))
x = Convolution2D(64, 3, 3, border_mode='valid', subsample=(2, 2))(input_img)
x = BatchNormalization(axis=3)(x)
x = Activation('relu')(x)
x = Convolution2D(128, 3, 3, border_mode='valid', subsample=(2, 2))(x)
x = BatchNormalization(axis=3)(x)
x = Activation('relu')(x)
x = Convolution2D(128, 3, 3, border_mode='valid', subsample=(2, 2))(x)
x = BatchNormalization(axis=3)(x)
x = Convolution2D(256, 3, 3, border_mode='valid', subsample=(2, 2))(x)
x = BatchNormalization(axis=3)(x)
encoded = Activation('relu')(x)

x = Deconvolution2D(128, 3, 3, output_shape=(batch_size, 7, 7, 128), border_mode='valid', subsample=(2, 2))(
    encoded)
x = BatchNormalization(axis=3)(x)
x = Deconvolution2D(128, 3, 3, output_shape=(batch_size, 15, 15, 128), border_mode='valid', subsample=(2, 2))(x)
x = BatchNormalization(axis=3)(x)
x = Activation('relu')(x)
x = Deconvolution2D(64, 3, 3, output_shape=(batch_size, 31, 31, 64), border_mode='valid', subsample=(2, 2))(x)
x = BatchNormalization(axis=3)(x)
x = Activation('relu')(x)
x = Deconvolution2D(32, 3, 3, output_shape=(batch_size, 63, 63, 32), border_mode='valid', subsample=(2, 2))(x)
x = BatchNormalization(axis=3)(x)
x = Activation('relu')(x)
decoded = Deconvolution2D(3, 2, 2, output_shape=(batch_size, 64, 64, 3), activation='tanh', border_mode='valid',
                          subsample=(1, 1))(x)

autoencoder = Model(input_img, decoded)
autoencoder.summary()
autoencoder.compile(optimizer='adam', loss='mse')

datagen = ImageDataGenerator(
    featurewise_center=False,  # set input mean to 0 over the dataset
    samplewise_center=False,  # set each sample mean to 0
    featurewise_std_normalization=False,  # divide inputs by std of the dataset
    samplewise_std_normalization=False,  # divide each input by its std
    zca_whitening=False,  # apply ZCA whitening
    rotation_range=False,  # randomly rotate images in the range (degrees, 0 to 180)
    width_shift_range=False,  # randomly shift images horizontally (fraction of total width)
    height_shift_range=False,  # randomly shift images vertically (fraction of total height)
    horizontal_flip=False,  # randomly flip images
    vertical_flip=False)  # randomly flip images

# compute quantities required for featurewise normalization
# (std, mean, and principal components if ZCA whitening is applied)
X_sample = data.get_sample(3000)
datagen.fit(X_sample)

for e in range(nb_epoch):
    print("epoch %d" % e)
    for X_train, Y_train, X_test, Y_test in data.generator():
        # fit the model on the batches generated by datagen.flow()
        autoencoder.fit_generator(datagen.flow(X_train, Y_train-X_train,
                                               batch_size=batch_size),
                                  samples_per_epoch=X_train.shape[0],
                                  nb_epoch=1,
                                  validation_data=(X_test, Y_test-X_test),
                                  callbacks=[TensorBoard(log_dir='./logs')])

decoded_imgs = autoencoder.predict(X_test, batch_size=batch_size) + X_test

montage(X_test[:100, :, :], 'ToonNet-X')
montage(decoded_imgs[:100, :, :], 'ToonNet-Out')
montage(Y_test[:100, :, :], 'ToonNet-Y')
